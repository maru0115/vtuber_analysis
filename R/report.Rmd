---
title: "個人勢Vtuberデータセットの解析"
output: html_notebook
---

# ライブラリの読み込み
```{r}
library(tidyverse)
library(corrplot)
library(stargazer)
library(car)
library(broom)
```

# データの読み込み

```{r}
data_livers = read_csv("../csv/livers_info.csv", quote = '"')
data_videos = read_csv("../csv/videos_info.csv", quote = '"')
```

# ビデオデータを要約
```{r}
data_videos_summary <-
  data_videos %>% 
  group_by(channelId, video_type) %>%
  summarise(count=n(), sum=sum(viewCount), median=median(viewCount), max=max(viewCount), .groups = "drop") %>% 
  pivot_wider(names_from=video_type, values_from=c(count, sum, median, max), values_fill = 0)
```


# チャンネル概要とビデオデータ要約結果を結合
```{r}
data_result <-
  data_livers %>% 
  inner_join(data_videos_summary, by="channelId") %>% 
  select(title, subscriberCount, ends_with("movie"), ends_with("live"), ends_with("short"))
```

# チャンネル登録者のヒストグラムを見て、明らかなハズレ値を確認
```{r}
data_result %>% 
  ggplot(
    aes(
      x = subscriberCount
    )
  ) +
  geom_histogram()
```
# ハズレ値を除去

```{r}
data_result2 <-
  data_result %>% 
  filter(between(subscriberCount, 100, 7500))
```

# 相関係数の一覧
```{r}
c<-
  data_result2 %>%
  select(-title) %>%
  cor()

p<-
  data_result2 %>%
  select(-title) %>%
  cor.mtest()

round(c,2)　#「c」の中の数値を小数点以下3桁で四捨五入する
corrplot(c, tl.col="black",tl.cex=1.0,tl.srt=45,p.mat=p[[1]],insig="blank",sig.level=0.05)
#corrplot(c, type="upper")
```
## わかりそうなこと

- 登録者と強く相関があるのは、1回あたりの配信の総来場者数
  - 配信の回数とは相関がない
  - 動画関連は弱い相関
  - ショート関連は相関がない 
  - 因果関係はこの段階では不明

- 動画・ショート投稿や配信の頻度と、一本あたり再生回数/一配信あたり総来場者数には関係がない
  - たくさん配信をしたからと言って、人がたくさん来るわけではない
  
- 配信一回あたりの総来場者数と動画の総再生回数には相関がある。
  - ショートとは相関がない

# それぞれの媒体の投稿比率
```{r}
cat("配信比率：",sum(data_result2$sum_live>1)/nrow(data_result2))
cat("\n動画投稿比率：",sum(data_result2$sum_movie>1)/nrow(data_result2))
cat("\nshort投稿比率：",sum(data_result2$sum_short>1)/nrow(data_result2))
```

# short再考

## ショート動画をどのくらい上げているかヒストグラムを書いてみる
```{r}
data_result2 %>% 
  filter(sum_short > 0) %>% 
  ggplot(
    aes(
      x = sum_short
    )
  ) +
  geom_histogram() +
  xlim(0,1000)
```

## ショートを上げている人限定で相関行列を作る

```{r}
data_short <-
  data_result2 %>% 
  filter(between(sum_short,1,1000))

c<-
  data_short %>%
  select(-title) %>%
  cor()

p<-
  data_short %>%
  select(-title) %>%
  cor.mtest()

round(c,2)　#「c」の中の数値を小数点以下3桁で四捨五入する
corrplot(c, tl.col="black",tl.cex=1.0,tl.srt=45,p.mat=p[[1]],insig="blank",sig.level=0.05)
#corrplot(c, type="upper")
```

### 考察
- short投稿者は配信頻度が低い -> short制作に時間を費やすため？
- shortの質が良いと、配信頻度が低くても配信一回あたりの総来場者が増えるので、  
  トータルでは配信に来る人が多くなる

# 同程度の配信頻度の人がShort動画を作るとどのくらい伸びる？

## 配信頻度を見てみる
```{r}
data_short %>% 
  ggplot(
    aes(
      x = count_live
    )
  ) +
  geom_histogram()
```
### ここから先はサンプル数不足になりそうなので未着手

# 動画再考

## 動画をどのくらい上げているかヒストグラムを書いてみる
```{r}
data_result2 %>% 
  filter(sum_movie > 0) %>% 
  ggplot(
    aes(
      x = sum_movie
    )
  ) +
  geom_histogram() +
  xlim(0,8000)
```

## 動画を上げている人限定で相関行列を作る

```{r}
data_movie <-
  data_result2 %>% 
  filter(between(sum_movie,1,8000))

c<-
  data_movie %>%
  select(-title) %>%
  cor()

p<-
  data_movie %>%
  select(-title) %>%
  cor.mtest()

round(c,2)　#「c」の中の数値を小数点以下3桁で四捨五入する
corrplot(c, tl.col="black",tl.cex=1.0,tl.srt=45,p.mat=p[[1]],insig="blank",sig.level=0.05)
#corrplot(c, type="upper")
```
  
# 統計情報の確認
```{r}
summary(data_result)
```

# 登録者を絞って見てみる
```{r}
data_result3 <-
  data_result %>% filter(between(subscriberCount, 100, 1000))
```

# 相関係数の一覧
```{r}
c<-
  data_result3 %>%
  select(-title) %>%
  cor(use="pairwise.complete.obs")

p<-
  data_result3 %>%
  select(-title) %>%
  cor.mtest(use="pairwise.complete.obs")

round(c,2)　#「c」の中の数値を小数点以下3桁で四捨五入する
corrplot(c, tl.col="black",tl.cex=1.0,tl.srt=45,p.mat=p[[1]],insig="blank",sig.level=0.01)
```

# 重回帰分析してみる

```{r}
reg = lm(subscriberCount ~ sum_movie + sum_live + sum_short, data_result2)
step(reg)
```

# 多重共線性(VIF>10かどうかで判別)
```{r}
vif(model)
```
# Q-Qプロット

```{r}
model = lm(formula = subscriberCount ~ count_live+ median_short, data = data_result2)

model %>% 
  augment() %>% 
  mutate(z_res = (.resid - mean(.resid)) / sd(.resid)) %>% 
  ggplot(aes(sample = z_res)) +
  geom_abline(a = 0, b = 1, linetype = 2, color = "red") +
  geom_qq()
```


```{r}
c
```








